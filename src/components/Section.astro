---
/**
 * Section Component – Order of Importance for Heading and Description Values:
 *
 * 1. **Section Override:** 
 *    - Use the values passed directly via the Section props (i.e. the "heading" and "description" props).
 *
 * 2. **Meta Values:**
 *    - If no direct override is provided, load the collection meta file (_meta.mdx, _meta.md, or _meta.json)
 *      and use the "heading" and "description" defined there.
 *
 * 3. **Auto-Fallback:**
 *    - If neither the Section props nor the meta file provide a value, automatically generate a default.
 *      For the heading, this fallback is the collection slug capitalized (e.g., "services" becomes "Services").
 *
 * This hierarchy ensures that the highest priority values are used where explicitly provided, 
 * while sensible defaults are always available.
 */
/**
 * Section Component – Determines heading, description, styles, component, and buttons.
 * Priority:
 * 1. Section props override meta.
 * 2. Otherwise, meta defaults.
 * 3. Otherwise, auto-fallback (e.g. collection name capitalized).
 */
 import Heading from "./Heading.jsx";
import Button from "./Button.jsx";
import ItemsTemplate from "./ItemsTemplate.astro";
import {
  resolveMetaProps,
  resolveHeading,
  resolveDescription,
  resolveButtonsArray,
  getSectionItems,
  resolveSectionStyles,
  resolveComponent,
} from "@/utils/SectionUtils";
import { capitalize } from "@/utils/ContentUtils";

const {
  collection: collectionName,
  query: queryType,
  component: ItemComponent, // Optional explicit component
  heading,
  description,
  buttons,
  sectionClass,
  contentClass,
  itemsClass,
  itemClass,
  buttonsSectionClass,
  ...props
} = Astro.props;

// Retrieve meta from the collection.
const meta = await resolveMetaProps(collectionName, queryType);
const defaultSection = meta.defaultSection || {};

// Merge style classes.
const {
  finalSectionClass,
  finalContentClass,
  finalItemsClass,
  finalButtonsSectionClass,
} = resolveSectionStyles(
  { sectionClass, contentClass, itemsClass, buttonsSectionClass },
  defaultSection
);

// Resolve headings and description.
const finalHeadingArray = resolveHeading(heading, meta.heading, collectionName);
const finalDescription = resolveDescription(description, meta.description);

// Determine the component to render.
const finalComponent = resolveComponent(ItemComponent, defaultSection.component);

// Fetch dynamic items if applicable.
let items = [];
const isDynamic = Boolean(collectionName && queryType);
if (isDynamic) {
  items = await getSectionItems(queryType, collectionName, Astro.url.pathname);
  if (items.length === 0) return;
}

const buttonsArray = resolveButtonsArray(
  buttons,
  meta.hasPage,
  collectionName,
  Astro.url.pathname
);
const itemsDefaultHasPage = meta.itemsHasPage ?? false;
---

{isDynamic ? (
  <section
    class={`${finalSectionClass} w-full py-[var(--template-spacing-lg)] lg:px-[var(--template-spacing-md)]`}
    data-collection={collectionName}
    {...props}
  >
    <div class={`${finalContentClass} w-3/4 my-[var(--template-spacing-lg)]`}>
      {finalHeadingArray.map((head, i) => {
        const headObj = typeof head === "string" ? { text: head } : head;
        const Tag = headObj.tagName || "h2";
        return <Heading key={i} tagName={Tag} className={headObj.class || ""}>{headObj.text}</Heading>;
      })}
      <slot name="aboveItemsInjection" />
      <ItemsTemplate
        items={items}
        collection={collectionName}
        query={queryType}
        itemsClass={finalItemsClass}
        itemClass={itemClass}
        ItemComponent={finalComponent}
        HasPage={itemsDefaultHasPage}
        pathname={Astro.url.pathname}
      />
      <slot name="belowItemsInjection" />
      <div class={finalButtonsSectionClass}>
        {buttonsArray.length > 0 &&
          buttonsArray.map((btn, index) => {
            const btnDefaults = {
              text: capitalize(collectionName),
              link: `/${collectionName}`,
              class: "",
              variant: "primary",
            };
            const finalButtonProps = { ...btnDefaults, ...btn };
            return (
              <Button
                key={index}
                href={finalButtonProps.link}
                className={finalButtonProps.class}
                ariaLabel={finalButtonProps.text}
                variant={finalButtonProps.variant}
              >
                {finalButtonProps.text}
              </Button>
            );
          })}
      </div>
      <slot />
    </div>
  </section>
) : (
  <section class={`${finalSectionClass} w-full lg:px-[var(--template-spacing-md)]`} {...props}>
    <div class={`${finalContentClass} w-3/4`}>
      {finalHeadingArray.map((head, i) => {
        const headObj = typeof head === "string" ? { text: head } : head;
        const Tag = headObj.tagName || "h2";
        return <Heading key={i} tagName={Tag} className={headObj.class || ""}>{headObj.text}</Heading>;
      })}
      {finalDescription && (
        <p class={description?.class}>
          {finalDescription}
        </p>
      )}
      <slot />
      <div class={finalButtonsSectionClass}>
        {buttonsArray.length > 0 &&
          buttonsArray.map((btn, index) => {
            const btnDefaults = {
              text: capitalize(collectionName),
              link: `/${collectionName}`,
              class: "",
              variant: "primary",
            };
            const finalButtonProps = { ...btnDefaults, ...btn };
            return (
              <Button
                key={index}
                href={finalButtonProps.link}
                className={finalButtonProps.class}
                ariaLabel={finalButtonProps.text}
                variant={finalButtonProps.variant}
              >
                {finalButtonProps.text}
              </Button>
            );
          })}
      </div>
    </div>
  </section>
)}
